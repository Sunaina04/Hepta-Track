{"ast":null,"code":"import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { selectCustomerId } from \"../Store/Slice/userSlice\";\n\n// Fetch base query configuration\nconst baseQuery = fetchBaseQuery({\n  baseUrl: process.env.REACT_APP_BASE_URL,\n  prepareHeaders: (headers, {\n    getState,\n    endpoint\n  }) => {\n    const state = getState();\n    const selectedCustomerId = selectCustomerId(state);\n    const refreshToken = sessionStorage.getItem(\"getRefreshToken\");\n    const noAuthEndpoints = [\"login\", \"resetPassword\", \"forgotPassword\"];\n    if (refreshToken && !noAuthEndpoints.includes(endpoint)) {\n      headers.set(\"Authorization\", `Bearer ${refreshToken}`);\n      const noAuthEndpointsForCustomer = [\"getCustomersOwners\"];\n      if (selectedCustomerId && !noAuthEndpointsForCustomer.includes(endpoint)) {\n        headers.set(\"CUSTOMER_OWNER_ID\", selectedCustomerId);\n      }\n    } else {\n      const token = state.user.token || sessionStorage.getItem(\"token\");\n      if (token && !noAuthEndpoints.includes(endpoint)) {\n        headers.set(\"Authorization\", `Bearer ${token}`);\n        const noAuthEndpointsForCustomer = [\"getCustomersOwners\"];\n        if (selectedCustomerId && !noAuthEndpointsForCustomer.includes(endpoint)) {\n          headers.set(\"CUSTOMER_OWNER_ID\", selectedCustomerId);\n        }\n      }\n    }\n    return headers;\n  }\n});\n\n// Function to fetch base query with interceptor\nconst baseQueryWithInterceptor = async (args, api, extraOptions) => {\n  try {\n    let result = await baseQuery(args, api, extraOptions);\n    if (result.error && result.error.status === 500) {\n      const token = sessionStorage.getItem(\"getRefreshToken\");\n      if (token) {\n        const newToken = await refreshToken(token);\n        if (newToken) {\n          // Retry the original request with the new token\n          result = await baseQuery(args, api, extraOptions);\n        }\n      }\n    }\n    return result;\n  } catch (error) {\n    throw error;\n  }\n};\n\n// Create API client\nexport const userApi = createApi({\n  reducerPath: \"api\",\n  baseQuery: baseQueryWithInterceptor,\n  endpoints: builder => ({})\n});\n\n// Function to refresh token\nconst refreshToken = async refreshToken => {\n  try {\n    const response = await fetch(`${process.env.REACT_APP_BASE_URL}/api/v1/auth/refresh?refreshToken=${refreshToken}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to refresh token\");\n    }\n    const data = await response.json();\n    if ((data === null || data === void 0 ? void 0 : data.status) === 200) {\n      sessionStorage.setItem(\"getRefreshToken\", data === null || data === void 0 ? void 0 : data.token);\n      return data === null || data === void 0 ? void 0 : data.token;\n    }\n  } catch (error) {\n    console.error(\"Error refreshing token:\", error);\n    throw error;\n  }\n};","map":{"version":3,"names":["createApi","fetchBaseQuery","selectCustomerId","baseQuery","baseUrl","process","env","REACT_APP_BASE_URL","prepareHeaders","headers","getState","endpoint","state","selectedCustomerId","refreshToken","sessionStorage","getItem","noAuthEndpoints","includes","set","noAuthEndpointsForCustomer","token","user","baseQueryWithInterceptor","args","api","extraOptions","result","error","status","newToken","userApi","reducerPath","endpoints","builder","response","fetch","method","ok","Error","data","json","setItem","console"],"sources":["/home/dell/MY PROJECTS/Hepta-Track/hepta-track/src/Services/UserApi.ts"],"sourcesContent":["import {\n  createApi,\n  fetchBaseQuery,\n  BaseQueryApi,\n  FetchArgs,\n} from \"@reduxjs/toolkit/query/react\";\nimport { RootState } from \"../Store/Store\";\nimport { selectCustomerId } from \"../Store/Slice/userSlice\";\n\n// Fetch base query configuration\nconst baseQuery = fetchBaseQuery({\n  baseUrl: process.env.REACT_APP_BASE_URL,\n  prepareHeaders: (headers, { getState, endpoint }) => {\n    const state = getState() as RootState;\n    const selectedCustomerId = selectCustomerId(state);\n    const refreshToken = sessionStorage.getItem(\"getRefreshToken\");\n    const noAuthEndpoints = [\"login\", \"resetPassword\", \"forgotPassword\"];\n\n    if (refreshToken && !noAuthEndpoints.includes(endpoint)) {\n      headers.set(\"Authorization\", `Bearer ${refreshToken}`);\n      const noAuthEndpointsForCustomer = [\"getCustomersOwners\"];\n      if (\n        selectedCustomerId &&\n        !noAuthEndpointsForCustomer.includes(endpoint)\n      ) {\n        headers.set(\"CUSTOMER_OWNER_ID\", selectedCustomerId);\n      }\n    } else {\n      const token = state.user.token || sessionStorage.getItem(\"token\");\n      if (token && !noAuthEndpoints.includes(endpoint)) {\n        headers.set(\"Authorization\", `Bearer ${token}`);\n        const noAuthEndpointsForCustomer = [\"getCustomersOwners\"];\n        if (\n          selectedCustomerId &&\n          !noAuthEndpointsForCustomer.includes(endpoint)\n        ) {\n          headers.set(\"CUSTOMER_OWNER_ID\", selectedCustomerId);\n        }\n      }\n    }\n\n    return headers;\n  },\n});\n\n// Function to fetch base query with interceptor\nconst baseQueryWithInterceptor = async (\n  args: FetchArgs | string,\n  api: BaseQueryApi,\n  extraOptions: { signal?: AbortSignal }\n) => {\n  try {\n    let result = await baseQuery(args, api, extraOptions);\n    if (result.error && result.error.status === 500) {\n      const token = sessionStorage.getItem(\"getRefreshToken\");\n      if (token) {\n        const newToken = await refreshToken(token);\n        if (newToken) {\n          // Retry the original request with the new token\n          result = await baseQuery(args, api, extraOptions);\n        }\n      }\n    }\n    return result;\n  } catch (error) {\n    throw error;\n  }\n};\n\n// Create API client\nexport const userApi = createApi({\n  reducerPath: \"api\",\n  baseQuery: baseQueryWithInterceptor,\n  endpoints: (builder) => ({}),\n});\n\n// Function to refresh token\nconst refreshToken = async (refreshToken: string) => {\n  try {\n    const response = await fetch(\n      `${process.env.REACT_APP_BASE_URL}/api/v1/auth/refresh?refreshToken=${refreshToken}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      }\n    );\n    if (!response.ok) {\n      throw new Error(\"Failed to refresh token\");\n    }\n    const data = await response.json();\n    if (data?.status === 200) {\n      sessionStorage.setItem(\"getRefreshToken\", data?.token);\n      return data?.token;\n    }\n  } catch (error) {\n    console.error(\"Error refreshing token:\", error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}